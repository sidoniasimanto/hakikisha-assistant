{"version":3,"file":"globalEndpointManager.js","sourceRoot":"","sources":["../../src/globalEndpointManager.ts"],"names":[],"mappings":";;;AAAA,uCAAuC;AACvC,kCAAkC;AAClC,gDAA+E;AAK/E,wDAAkD;AAElD,iEAA4D;AAE5D,2DAAiE;AACjE,qDAAwD;AACxD,kDAA+D;AAE/D;;;GAGG;AACH,MAAa,qBAAqB;IAuCtB;IAtCV;;OAEG;IACK,eAAe,CAAS;IAChC;;OAEG;IACI,uBAAuB,CAAU;IAChC,YAAY,CAAU;IACtB,OAAO,CAAsB;IACrC;;OAEG;IACK,kBAAkB,CAAW;IAC7B,kBAAkB,GAAe,EAAE,CAAC;IACpC,iBAAiB,GAAe,EAAE,CAAC;IACnC,4BAA4B,GAAe,EAAE,CAAC;IAC9C,6BAA6B,GAAe,EAAE,CAAC;IAC/C,4BAA4B,CAAU;IAEvC,uBAAuB,CAAS;IACvC;;;OAGG;IACI,4BAA4B,CAAU;IAC7C;;;OAGG;IACI,kCAAkC,CAAU;IAEnD;;;OAGG;IACH,YACE,OAA4B,EACpB,mBAGuC;QAHvC,wBAAmB,GAAnB,mBAAmB,CAGoB;QAE/C,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,eAAe,GAAG,OAAO,CAAC,QAAQ,CAAC;QACxC,IAAI,CAAC,uBAAuB,GAAG,OAAO,CAAC,gBAAgB,CAAC,uBAAuB,CAAC;QAChF,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;QAC1B,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,OAAO,CAAC,gBAAgB,CAAC,kBAAkB,CAAC;QAC3E,IAAI,CAAC,uBAAuB,GAAG,IAAI,CAAC,kBAAkB,CAAC,CAAC,CAAC,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;QAC5F,IAAI,CAAC,4BAA4B,GAAG,OAAO,CAAC,gBAAgB,CAAC,4BAA4B,CAAC;QAC1F,IAAI,CAAC,kCAAkC;YACrC,OAAO,CAAC,gBAAgB,CAAC,kCAAkC;gBAC3D,OAAO,CAAC,gBAAgB,CAAC,4BAA4B,CAAC;IAC1D,CAAC;IAED;;OAEG;IACI,KAAK,CAAC,eAAe,CAAC,cAAsC;QACjE,OAAO,IAAI,CAAC,sBAAsB,CAAC,cAAc,EAAE,uBAAY,CAAC,IAAI,EAAE,wBAAa,CAAC,IAAI,CAAC,CAAC;IAC5F,CAAC;IAED;;OAEG;IACI,KAAK,CAAC,gBAAgB,CAAC,cAAsC;QAClE,OAAO,IAAI,CAAC,sBAAsB,CAAC,cAAc,EAAE,uBAAY,CAAC,IAAI,EAAE,wBAAa,CAAC,OAAO,CAAC,CAAC;IAC/F,CAAC;IAEM,KAAK,CAAC,gBAAgB;QAC3B,OAAO,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,CAAC,uBAAuB,CAAC,CAAC;IAC1E,CAAC;IAEM,KAAK,CAAC,iBAAiB;QAC5B,OAAO,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,CAAC,uBAAuB,CAAC,CAAC;IAC3E,CAAC;IAED;;OAEG;IACI,KAAK,CAAC,gBAAgB;QAC3B,OAAO,IAAI,CAAC,iBAAiB,CAAC;IAChC,CAAC;IAEM,KAAK,CAAC,qCAAqC,CAChD,cAAsC,EACtC,QAAgB;QAEhB,MAAM,IAAI,CAAC,mBAAmB,CAAC,cAAc,CAAC,CAAC;QAC/C,MAAM,QAAQ,GAAG,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,CAAC,uBAAuB,KAAK,QAAQ,CAAC,CAAC;QAChG,IAAI,QAAQ,EAAE,CAAC;YACb,QAAQ,CAAC,WAAW,GAAG,IAAI,CAAC;YAC5B,QAAQ,CAAC,+BAA+B,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;YACtD,IAAI,CAAC,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QACnD,CAAC;IACH,CAAC;IAEM,KAAK,CAAC,sCAAsC,CACjD,cAAsC,EACtC,QAAgB;QAEhB,MAAM,IAAI,CAAC,mBAAmB,CAAC,cAAc,CAAC,CAAC;QAC/C,MAAM,QAAQ,GAAG,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAC3C,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,CAAC,uBAAuB,KAAK,QAAQ,CAClD,CAAC;QACF,IAAI,QAAQ,EAAE,CAAC;YACb,QAAQ,CAAC,WAAW,GAAG,IAAI,CAAC;YAC5B,QAAQ,CAAC,+BAA+B,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;YACtD,IAAI,CAAC,6BAA6B,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QACpD,CAAC;IACH,CAAC;IAEM,4BAA4B,CACjC,YAA2B,EAC3B,aAA6B;QAE7B,IAAI,MAAM,GACR,IAAI,CAAC,OAAO,CAAC,gBAAgB,CAAC,yBAAyB,IAAI,IAAI,CAAC,4BAA4B,CAAC;QAE/F,IAAI,YAAY,EAAE,CAAC;YACjB,MAAM;gBACJ,MAAM;oBACN,CAAC,YAAY,KAAK,uBAAY,CAAC,IAAI;wBACjC,CAAC,YAAY,KAAK,uBAAY,CAAC,KAAK,IAAI,aAAa,KAAK,wBAAa,CAAC,OAAO,CAAC,CAAC,CAAC;QACxF,CAAC;QAED,OAAO,MAAM,CAAC;IAChB,CAAC;IAEO,6BAA6B,CACnC,oBAA8B,EAAE,EAChC,YAA0B;QAE1B,IAAI,CAAC,IAAA,qCAAyB,EAAC,YAAY,CAAC,EAAE,CAAC;YAC7C,OAAO,IAAI,GAAG,EAAE,CAAC;QACnB,CAAC;QAED,OAAO,iBAAiB,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,GAAG,CAAC,iBAAiB,CAAC,GAAG,CAAC,+BAAiB,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,GAAG,EAAE,CAAC;IAClG,CAAC;IAEO,uBAAuB,CAC7B,kBAA4B,EAC5B,iBAA+B;QAE/B,IAAI,CAAC,iBAAiB,IAAI,iBAAiB,CAAC,IAAI,KAAK,CAAC,EAAE,CAAC;YACvD,OAAO,kBAAkB,CAAC;QAC5B,CAAC;QACD,MAAM,iBAAiB,GAAG,kBAAkB,CAAC,MAAM,CAAC,CAAC,QAAQ,EAAE,EAAE;YAC/D,OAAO,CAAC,iBAAiB,CAAC,GAAG,CAAC,IAAA,+BAAiB,EAAC,QAAQ,CAAC,CAAC,CAAC;QAC7D,CAAC,CAAC,CAAC;QACH,OAAO,iBAAiB,CAAC;IAC3B,CAAC;IAEM,KAAK,CAAC,sBAAsB,CACjC,cAAsC,EACtC,YAA0B,EAC1B,aAA4B,EAC5B,4BAAoC,CAAC;QAErC,OAAO,IAAI,CAAC,8BAA8B,CAAC;YACzC,cAAc,EAAE,cAAc;YAC9B,YAAY,EAAE,YAAY;YAC1B,aAAa,EAAE,aAAa;YAC5B,yBAAyB,EAAE,yBAAyB;SACrD,CAAC,CAAC;IACL,CAAC;IAED;;OAEG;IACI,KAAK,CAAC,8BAA8B,CACzC,6BAA4D;QAE5D,wDAAwD;QACxD,MAAM,EACJ,cAAc,EACd,YAAY,EACZ,aAAa,EACb,yBAAyB,EACzB,iBAAiB,GAAG,EAAE,GACvB,GAAG,6BAA6B,CAAC;QAElC,2EAA2E;QAE3E,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,gBAAgB,CAAC,uBAAuB,EAAE,CAAC;YAC3D,cAAc,CAAC,OAAO,CAAC,EAAE,aAAa,EAAE,IAAI,EAAE,EAAE,kBAAkB,CAAC,CAAC;YACpE,cAAc,CAAC,wBAAwB,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;YAC9D,OAAO,IAAI,CAAC,eAAe,CAAC;QAC9B,CAAC;QAED,yEAAyE;QACzE,IAAI,YAAY,KAAK,uBAAY,CAAC,IAAI,EAAE,CAAC;YACvC,cAAc,CAAC,OAAO,CAAC,EAAE,aAAa,EAAE,IAAI,EAAE,EAAE,eAAe,CAAC,CAAC;YACjE,cAAc,CAAC,wBAAwB,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;YAC9D,OAAO,IAAI,CAAC,eAAe,CAAC;QAC9B,CAAC;QACD,IAAI,IAAI,CAAC,iBAAiB,CAAC,MAAM,KAAK,CAAC,IAAI,IAAI,CAAC,kBAAkB,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YAChF,MAAM,gBAAgB,GAAG,MAAM,IAAA,wCAAuB,EACpD,KAAK,EAAE,YAAoC,EAAE,EAAE;gBAC7C,OAAO,IAAI,CAAC,mBAAmB,CAAC,YAAY,EAAE;oBAC5C,aAAa,EAAE,IAAI,CAAC,eAAe;iBACpC,CAAC,CAAC;YACL,CAAC,EACD,cAAc,EACd,yCAAkB,CAAC,qBAAqB,CACzC,CAAC;YAEF,IAAI,CAAC,kBAAkB,GAAG,gBAAgB,CAAC,QAAQ,CAAC,iBAAiB,CAAC;YACtE,IAAI,CAAC,iBAAiB,GAAG,gBAAgB,CAAC,QAAQ,CAAC,iBAAiB,CAAC;YACrE,IAAI,CAAC,4BAA4B,GAAG,gBAAgB,CAAC,QAAQ,CAAC,+BAA+B,CAAC;YAC9F,IAAI,CAAC,sBAAsB,CAAC,gBAAgB,CAAC,QAAQ,CAAC,0BAA0B,CAAC,CAAC;QACpF,CAAC;QAED,MAAM,SAAS,GAAG,IAAA,wBAAa,EAAC,aAAa,CAAC;YAC5C,CAAC,CAAC,IAAI,CAAC,iBAAiB;YACxB,CAAC,CAAC,IAAI,CAAC,kBAAkB,CAAC;QAE5B,MAAM,0BAA0B,GAAG,IAAI,CAAC,6BAA6B,CACnE,iBAAiB,EACjB,YAAY,CACb,CAAC;QACF,cAAc,CAAC,OAAO,CACpB,EAAE,iBAAiB,EAAE,KAAK,CAAC,IAAI,CAAC,0BAA0B,CAAC,EAAE,EAC7D,oBAAoB,CACrB,CAAC;QAEF,uCAAuC;QACvC,MAAM,kBAAkB,GAAG,IAAI,CAAC,uBAAuB,CACrD,IAAI,CAAC,kBAAkB,EACvB,0BAA0B,CAC3B,CAAC;QAEF,IAAI,QAAQ,CAAC;QACb,wFAAwF;QACxF,IACE,kBAAkB;YAClB,kBAAkB,CAAC,MAAM,GAAG,CAAC;YAC7B,yBAAyB,GAAG,kBAAkB,CAAC,MAAM,EACrD,CAAC;YACD,IAAI,CAAC,uBAAuB,GAAG,kBAAkB,CAAC,MAAM,CAAC;YAEzD,KAAK,IAAI,CAAC,GAAG,yBAAyB,EAAE,CAAC,GAAG,kBAAkB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gBAC3E,MAAM,iBAAiB,GAAG,kBAAkB,CAAC,CAAC,CAAC,CAAC;gBAChD,QAAQ,GAAG,SAAS,CAAC,IAAI,CACvB,CAAC,GAAG,EAAE,EAAE,CACN,GAAG,CAAC,WAAW,KAAK,IAAI;oBACxB,IAAA,+BAAiB,EAAC,GAAG,CAAC,IAAI,CAAC,KAAK,IAAA,+BAAiB,EAAC,iBAAiB,CAAC,CACvE,CAAC;gBACF,IAAI,QAAQ,EAAE,CAAC;oBACb,MAAM;gBACR,CAAC;YACH,CAAC;QACH,CAAC;QAED,4FAA4F;QAC5F,IAAI,CAAC,QAAQ,EAAE,CAAC;YACd,MAAM,eAAe,GACnB,yBAAyB,IAAI,CAAC,IAAI,yBAAyB,GAAG,SAAS,CAAC,MAAM,CAAC;YACjF,MAAM,iBAAiB,GAAG,eAAe;gBACvC,CAAC,CAAC,SAAS,CAAC,KAAK,CAAC,yBAAyB,CAAC;gBAC5C,CAAC,CAAC,SAAS,CAAC;YACd,QAAQ,GAAG,iBAAiB,CAAC,IAAI,CAAC,CAAC,GAAG,EAAE,EAAE;gBACxC,OAAO,CACL,GAAG,CAAC,WAAW,KAAK,IAAI,IAAI,CAAC,0BAA0B,CAAC,GAAG,CAAC,IAAA,+BAAiB,EAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CACzF,CAAC;YACJ,CAAC,CAAC,CAAC;QACL,CAAC;QAED,QAAQ,GAAG,QAAQ,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE,EAAE,uBAAuB,EAAE,IAAI,CAAC,eAAe,EAAE,CAAC;QAC7F,cAAc,CAAC,wBAAwB,CAAC,QAAQ,CAAC,uBAAuB,CAAC,CAAC;QAC1E,OAAO,QAAQ,CAAC,uBAAuB,CAAC;IAC1C,CAAC;IAED;;;;;OAKG;IACI,KAAK,CAAC,mBAAmB,CAAC,cAAsC;QACrE,IAAI,CAAC,IAAI,CAAC,YAAY,IAAI,IAAI,CAAC,uBAAuB,EAAE,CAAC;YACvD,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;YACzB,MAAM,eAAe,GAAG,MAAM,IAAI,CAAC,iCAAiC,CAAC,cAAc,CAAC,CAAC;YACrF,IAAI,eAAe,EAAE,CAAC;gBACpB,IAAI,CAAC,gCAAgC,EAAE,CAAC;gBACxC,IAAI,CAAC,gBAAgB,CAAC,eAAe,CAAC,CAAC;YACzC,CAAC;YACD,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;QAC5B,CAAC;IACH,CAAC;IAEO,gBAAgB,CAAC,eAAgC;QACvD,MAAM,oBAAoB,GAAG,IAAI,CAAC,kBAAkB,CAAC;QACrD,MAAM,oBAAoB,GAAG,IAAI,CAAC,iBAAiB,CAAC;QAEpD,SAAS,KAAK,CAAC,GAAa,EAAE,OAAmB;YAC/C,MAAM,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,KAAK,GAAG,CAAC,IAAI,CAAC,CAAC;YACtD,IAAI,IAAI,EAAE,CAAC;gBACT,GAAG,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC;gBACnC,GAAG,CAAC,+BAA+B,GAAG,IAAI,CAAC,+BAA+B,CAAC;YAC7E,CAAC;YACD,OAAO,GAAG,CAAC;QACb,CAAC;QAED,IAAI,CAAC,kBAAkB,GAAG,eAAe,CAAC,iBAAiB,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,CACtE,KAAK,CAAC,EAAE,GAAG,GAAG,EAAE,EAAE,oBAAoB,CAAC,CACxC,CAAC;QACF,IAAI,CAAC,iBAAiB,GAAG,eAAe,CAAC,iBAAiB,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,CACrE,KAAK,CAAC,EAAE,GAAG,GAAG,EAAE,EAAE,oBAAoB,CAAC,CACxC,CAAC;IACJ,CAAC;IAEO,gCAAgC;QACtC,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QACvB,IAAI,CAAC,cAAc,CAAC,GAAG,EAAE,IAAI,CAAC,4BAA4B,EAAE,IAAI,CAAC,iBAAiB,CAAC,CAAC;QACpF,IAAI,CAAC,4BAA4B,GAAG,IAAI,CAAC,4BAA4B,CACnE,GAAG,EACH,IAAI,CAAC,4BAA4B,CAClC,CAAC;QAEF,IAAI,CAAC,cAAc,CAAC,GAAG,EAAE,IAAI,CAAC,6BAA6B,EAAE,IAAI,CAAC,kBAAkB,CAAC,CAAC;QACtF,IAAI,CAAC,6BAA6B,GAAG,IAAI,CAAC,4BAA4B,CACpE,GAAG,EACH,IAAI,CAAC,6BAA6B,CACnC,CAAC;IACJ,CAAC;IAED;;;;;OAKG;IACK,cAAc,CACpB,GAAW,EACX,oBAAgC,EAChC,YAAwB;QAExB,KAAK,MAAM,QAAQ,IAAI,oBAAoB,EAAE,CAAC;YAC5C,MAAM,mBAAmB,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,CAAC,IAAI,KAAK,QAAQ,CAAC,IAAI,CAAC,CAAC;YACnF,IACE,mBAAmB;gBACnB,GAAG,GAAG,mBAAmB,CAAC,+BAA+B;oBACvD,wBAAS,CAAC,qCAAqC,EACjD,CAAC;gBACD,mBAAmB,CAAC,WAAW,GAAG,KAAK,CAAC;YAC1C,CAAC;QACH,CAAC;IACH,CAAC;IAEO,4BAA4B,CAAC,GAAW,EAAE,oBAAgC;QAChF,OAAO,oBAAoB,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,EAAE;YACzC,OAAO,CACL,GAAG,GAAG,GAAG,CAAC,+BAA+B,GAAG,wBAAS,CAAC,qCAAqC,CAC5F,CAAC;QACJ,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;;;OAIG;IACK,KAAK,CAAC,iCAAiC,CAC7C,cAAsC;QAEtC,IAAI,CAAC;YACH,MAAM,OAAO,GAAG,EAAE,aAAa,EAAE,IAAI,CAAC,eAAe,EAAE,CAAC;YACxD,MAAM,EAAE,QAAQ,EAAE,eAAe,EAAE,GAAG,MAAM,IAAI,CAAC,mBAAmB,CAAC,cAAc,EAAE,OAAO,CAAC,CAAC;YAC9F,OAAO,eAAe,CAAC;YACvB,iFAAiF;YACjF,sDAAsD;YACtD,yFAAyF;YACzF,2DAA2D;YAC3D,iGAAiG;YACjG,yDAAyD;QAC3D,CAAC;QAAC,OAAO,GAAQ,EAAE,CAAC;YAClB,gBAAgB;QAClB,CAAC;QAED,IAAI,IAAI,CAAC,kBAAkB,EAAE,CAAC;YAC5B,KAAK,MAAM,QAAQ,IAAI,IAAI,CAAC,kBAAkB,EAAE,CAAC;gBAC/C,IAAI,CAAC;oBACH,MAAM,kBAAkB,GAAG,qBAAqB,CAAC,qBAAqB,CACpE,IAAI,CAAC,eAAe,EACpB,QAAQ,CACT,CAAC;oBACF,MAAM,OAAO,GAAG,EAAE,aAAa,EAAE,kBAAkB,EAAE,CAAC;oBACtD,MAAM,EAAE,QAAQ,EAAE,eAAe,EAAE,GAAG,MAAM,IAAI,CAAC,mBAAmB,CAClE,cAAc,EACd,OAAO,CACR,CAAC;oBACF,IAAI,eAAe,EAAE,CAAC;wBACpB,OAAO,eAAe,CAAC;oBACzB,CAAC;gBACH,CAAC;gBAAC,OAAO,GAAQ,EAAE,CAAC;oBAClB,gBAAgB;gBAClB,CAAC;YACH,CAAC;QACH,CAAC;IACH,CAAC;IAED;;;;;OAKG;IACK,MAAM,CAAC,qBAAqB,CAAC,eAAuB,EAAE,YAAoB;QAChF,sGAAsG;QACtG,sFAAsF;QACtF,iCAAiC;QACjC,MAAM,WAAW,GAAG,IAAI,GAAG,CAAC,eAAe,CAAC,CAAC;QAE7C,8EAA8E;QAC9E,IAAI,WAAW,CAAC,QAAQ,EAAE,CAAC;YACzB,MAAM,aAAa,GAAG,WAAW,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC,WAAW,EAAE,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;YAC/E,IAAI,aAAa,EAAE,CAAC;gBAClB,kDAAkD;gBAClD,MAAM,yBAAyB,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC;gBAEnD,0FAA0F;gBAC1F,MAAM,6BAA6B,GACjC,yBAAyB,GAAG,GAAG,GAAG,YAAY,CAAC,OAAO,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC;gBAElE,8CAA8C;gBAC9C,+EAA+E;gBAC/E,MAAM,kBAAkB,GAAG,eAAe;qBACvC,WAAW,EAAE;qBACb,OAAO,CAAC,yBAAyB,EAAE,6BAA6B,CAAC,CAAC;gBACrE,OAAO,kBAAkB,CAAC;YAC5B,CAAC;QACH,CAAC;QAED,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;;;OAIG;IACK,sBAAsB,CAAC,0BAAmC;QAChE,uFAAuF;QACvF,gCAAgC;QAChC,IAAI,0BAA0B,KAAK,KAAK,EAAE,CAAC;YACzC,IAAI,CAAC,4BAA4B,GAAG,0BAA0B,CAAC;YAC/D,IAAI,CAAC,kCAAkC,GAAG,0BAA0B,CAAC;QACvE,CAAC;IACH,CAAC;CACF;AAncD,sDAmcC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { OperationType, ResourceType, isReadRequest } from \"./common/index.js\";\nimport type { CosmosClientOptions } from \"./CosmosClientOptions.js\";\nimport type { Location, DatabaseAccount } from \"./documents/index.js\";\nimport type { RequestOptions } from \"./index.js\";\nimport type { ResolveServiceEndpointOptions } from \"./GlobalEndpointManagerOptions.js\";\nimport { Constants } from \"./common/constants.js\";\nimport type { ResourceResponse } from \"./request/index.js\";\nimport { MetadataLookUpType } from \"./CosmosDiagnostics.js\";\nimport type { DiagnosticNodeInternal } from \"./diagnostics/DiagnosticNodeInternal.js\";\nimport { withMetadataDiagnostics } from \"./utils/diagnostics.js\";\nimport { normalizeEndpoint } from \"./utils/checkURL.js\";\nimport { canApplyExcludedLocations } from \"./common/helper.js\";\n\n/**\n * @hidden\n * This internal class implements the logic for endpoint management for geo-replicated database accounts.\n */\nexport class GlobalEndpointManager {\n  /**\n   * The endpoint used to create the client instance.\n   */\n  private defaultEndpoint: string;\n  /**\n   * Flag to enable/disable automatic redirecting of requests based on read/write operations.\n   */\n  public enableEndpointDiscovery: boolean;\n  private isRefreshing: boolean;\n  private options: CosmosClientOptions;\n  /**\n   * List of azure regions to be used as preferred locations for read requests.\n   */\n  private preferredLocations: string[];\n  private writeableLocations: Location[] = [];\n  private readableLocations: Location[] = [];\n  private unavailableReadableLocations: Location[] = [];\n  private unavailableWriteableLocations: Location[] = [];\n  private enableMultipleWriteLocations: boolean;\n\n  public preferredLocationsCount: number;\n  /**\n   * Flag to enable/disable the Per Partition Level Failover (PPAF)\n   * @internal\n   */\n  public enablePartitionLevelFailover: boolean;\n  /**\n   * Flag to enable/disable the Per Partition Level Circuit Breaker (PPCB)\n   * @internal\n   */\n  public enablePartitionLevelCircuitBreaker: boolean;\n\n  /**\n   * @param options - The document client instance.\n   * @internal\n   */\n  constructor(\n    options: CosmosClientOptions,\n    private readDatabaseAccount: (\n      diagnosticNode: DiagnosticNodeInternal,\n      opts: RequestOptions,\n    ) => Promise<ResourceResponse<DatabaseAccount>>,\n  ) {\n    this.options = options;\n    this.defaultEndpoint = options.endpoint;\n    this.enableEndpointDiscovery = options.connectionPolicy.enableEndpointDiscovery;\n    this.isRefreshing = false;\n    this.preferredLocations = this.options.connectionPolicy.preferredLocations;\n    this.preferredLocationsCount = this.preferredLocations ? this.preferredLocations.length : 0;\n    this.enablePartitionLevelFailover = options.connectionPolicy.enablePartitionLevelFailover;\n    this.enablePartitionLevelCircuitBreaker =\n      options.connectionPolicy.enablePartitionLevelCircuitBreaker ||\n      options.connectionPolicy.enablePartitionLevelFailover;\n  }\n\n  /**\n   * Gets the current read endpoint from the endpoint cache.\n   */\n  public async getReadEndpoint(diagnosticNode: DiagnosticNodeInternal): Promise<string> {\n    return this.resolveServiceEndpoint(diagnosticNode, ResourceType.item, OperationType.Read);\n  }\n\n  /**\n   * Gets the current write endpoint from the endpoint cache.\n   */\n  public async getWriteEndpoint(diagnosticNode: DiagnosticNodeInternal): Promise<string> {\n    return this.resolveServiceEndpoint(diagnosticNode, ResourceType.item, OperationType.Replace);\n  }\n\n  public async getReadEndpoints(): Promise<ReadonlyArray<string>> {\n    return this.readableLocations.map((loc) => loc.databaseAccountEndpoint);\n  }\n\n  public async getWriteEndpoints(): Promise<ReadonlyArray<string>> {\n    return this.writeableLocations.map((loc) => loc.databaseAccountEndpoint);\n  }\n\n  /**\n   * Gets the read locations from the endpoint cache.\n   */\n  public async getReadLocations(): Promise<ReadonlyArray<Location>> {\n    return this.readableLocations;\n  }\n\n  public async markCurrentLocationUnavailableForRead(\n    diagnosticNode: DiagnosticNodeInternal,\n    endpoint: string,\n  ): Promise<void> {\n    await this.refreshEndpointList(diagnosticNode);\n    const location = this.readableLocations.find((loc) => loc.databaseAccountEndpoint === endpoint);\n    if (location) {\n      location.unavailable = true;\n      location.lastUnavailabilityTimestampInMs = Date.now();\n      this.unavailableReadableLocations.push(location);\n    }\n  }\n\n  public async markCurrentLocationUnavailableForWrite(\n    diagnosticNode: DiagnosticNodeInternal,\n    endpoint: string,\n  ): Promise<void> {\n    await this.refreshEndpointList(diagnosticNode);\n    const location = this.writeableLocations.find(\n      (loc) => loc.databaseAccountEndpoint === endpoint,\n    );\n    if (location) {\n      location.unavailable = true;\n      location.lastUnavailabilityTimestampInMs = Date.now();\n      this.unavailableWriteableLocations.push(location);\n    }\n  }\n\n  public canUseMultipleWriteLocations(\n    resourceType?: ResourceType,\n    operationType?: OperationType,\n  ): boolean {\n    let canUse =\n      this.options.connectionPolicy.useMultipleWriteLocations && this.enableMultipleWriteLocations;\n\n    if (resourceType) {\n      canUse =\n        canUse &&\n        (resourceType === ResourceType.item ||\n          (resourceType === ResourceType.sproc && operationType === OperationType.Execute));\n    }\n\n    return canUse;\n  }\n\n  private getEffectiveExcludedLocations(\n    excludedLocations: string[] = [],\n    resourceType: ResourceType,\n  ): Set<string> {\n    if (!canApplyExcludedLocations(resourceType)) {\n      return new Set();\n    }\n\n    return excludedLocations.length ? new Set(excludedLocations.map(normalizeEndpoint)) : new Set();\n  }\n\n  private filterExcludedLocations(\n    preferredLocations: string[],\n    excludedLocations?: Set<string>,\n  ): string[] {\n    if (!excludedLocations || excludedLocations.size === 0) {\n      return preferredLocations;\n    }\n    const filteredLocations = preferredLocations.filter((location) => {\n      return !excludedLocations.has(normalizeEndpoint(location));\n    });\n    return filteredLocations;\n  }\n\n  public async resolveServiceEndpoint(\n    diagnosticNode: DiagnosticNodeInternal,\n    resourceType: ResourceType,\n    operationType: OperationType,\n    startServiceEndpointIndex: number = 0, // Represents the starting index for selecting servers.\n  ): Promise<string> {\n    return this.resolveServiceEndpointInternal({\n      diagnosticNode: diagnosticNode,\n      resourceType: resourceType,\n      operationType: operationType,\n      startServiceEndpointIndex: startServiceEndpointIndex,\n    });\n  }\n\n  /**\n   * @internal\n   */\n  public async resolveServiceEndpointInternal(\n    resolveServiceEndpointOptions: ResolveServiceEndpointOptions,\n  ): Promise<string> {\n    // Extract all fields from ResolveServiceEndpointOptions\n    const {\n      diagnosticNode,\n      resourceType,\n      operationType,\n      startServiceEndpointIndex,\n      excludedLocations = [],\n    } = resolveServiceEndpointOptions;\n\n    // If endpoint discovery is disabled, always use the user provided endpoint\n\n    if (!this.options.connectionPolicy.enableEndpointDiscovery) {\n      diagnosticNode.addData({ readFromCache: true }, \"default_endpoint\");\n      diagnosticNode.recordEndpointResolution(this.defaultEndpoint);\n      return this.defaultEndpoint;\n    }\n\n    // If getting the database account, always use the user provided endpoint\n    if (resourceType === ResourceType.none) {\n      diagnosticNode.addData({ readFromCache: true }, \"none_resource\");\n      diagnosticNode.recordEndpointResolution(this.defaultEndpoint);\n      return this.defaultEndpoint;\n    }\n    if (this.readableLocations.length === 0 || this.writeableLocations.length === 0) {\n      const resourceResponse = await withMetadataDiagnostics(\n        async (metadataNode: DiagnosticNodeInternal) => {\n          return this.readDatabaseAccount(metadataNode, {\n            urlConnection: this.defaultEndpoint,\n          });\n        },\n        diagnosticNode,\n        MetadataLookUpType.DatabaseAccountLookUp,\n      );\n\n      this.writeableLocations = resourceResponse.resource.writableLocations;\n      this.readableLocations = resourceResponse.resource.readableLocations;\n      this.enableMultipleWriteLocations = resourceResponse.resource.enableMultipleWritableLocations;\n      this.refreshPPAFFeatureFlag(resourceResponse.resource.enablePerPartitionFailover);\n    }\n\n    const locations = isReadRequest(operationType)\n      ? this.readableLocations\n      : this.writeableLocations;\n\n    const effectiveExcludedLocations = this.getEffectiveExcludedLocations(\n      excludedLocations,\n      resourceType,\n    );\n    diagnosticNode.addData(\n      { excludedLocations: Array.from(effectiveExcludedLocations) },\n      \"excluded_locations\",\n    );\n\n    // Filter locations based on exclusions\n    const availableLocations = this.filterExcludedLocations(\n      this.preferredLocations,\n      effectiveExcludedLocations,\n    );\n\n    let location;\n    // If we have preferred locations, try each one in order and use the first available one\n    if (\n      availableLocations &&\n      availableLocations.length > 0 &&\n      startServiceEndpointIndex < availableLocations.length\n    ) {\n      this.preferredLocationsCount = availableLocations.length;\n\n      for (let i = startServiceEndpointIndex; i < availableLocations.length; i++) {\n        const preferredLocation = availableLocations[i];\n        location = locations.find(\n          (loc) =>\n            loc.unavailable !== true &&\n            normalizeEndpoint(loc.name) === normalizeEndpoint(preferredLocation),\n        );\n        if (location) {\n          break;\n        }\n      }\n    }\n\n    // If no preferred locations or one did not match, just grab the first one that is available\n    if (!location) {\n      const startIndexValid =\n        startServiceEndpointIndex >= 0 && startServiceEndpointIndex < locations.length;\n      const locationsToSearch = startIndexValid\n        ? locations.slice(startServiceEndpointIndex)\n        : locations;\n      location = locationsToSearch.find((loc) => {\n        return (\n          loc.unavailable !== true && !effectiveExcludedLocations.has(normalizeEndpoint(loc.name))\n        );\n      });\n    }\n\n    location = location ? location : { name: \"\", databaseAccountEndpoint: this.defaultEndpoint };\n    diagnosticNode.recordEndpointResolution(location.databaseAccountEndpoint);\n    return location.databaseAccountEndpoint;\n  }\n\n  /**\n   * Refreshes the endpoint list by clearning stale unavailability and then\n   *  retrieving the writable and readable locations from the geo-replicated database account\n   *  and then updating the locations cache.\n   *  We skip the refreshing if enableEndpointDiscovery is set to False\n   */\n  public async refreshEndpointList(diagnosticNode: DiagnosticNodeInternal): Promise<void> {\n    if (!this.isRefreshing && this.enableEndpointDiscovery) {\n      this.isRefreshing = true;\n      const databaseAccount = await this.getDatabaseAccountFromAnyEndpoint(diagnosticNode);\n      if (databaseAccount) {\n        this.refreshStaleUnavailableLocations();\n        this.refreshEndpoints(databaseAccount);\n      }\n      this.isRefreshing = false;\n    }\n  }\n\n  private refreshEndpoints(databaseAccount: DatabaseAccount): void {\n    const oldWritableLocations = this.writeableLocations;\n    const oldReadableLocations = this.readableLocations;\n\n    function merge(loc: Location, oldList: Location[]): Location {\n      const prev = oldList.find((o) => o.name === loc.name);\n      if (prev) {\n        loc.unavailable = prev.unavailable;\n        loc.lastUnavailabilityTimestampInMs = prev.lastUnavailabilityTimestampInMs;\n      }\n      return loc;\n    }\n\n    this.writeableLocations = databaseAccount.writableLocations.map((loc) =>\n      merge({ ...loc }, oldWritableLocations),\n    );\n    this.readableLocations = databaseAccount.readableLocations.map((loc) =>\n      merge({ ...loc }, oldReadableLocations),\n    );\n  }\n\n  private refreshStaleUnavailableLocations(): void {\n    const now = Date.now();\n    this.updateLocation(now, this.unavailableReadableLocations, this.readableLocations);\n    this.unavailableReadableLocations = this.cleanUnavailableLocationList(\n      now,\n      this.unavailableReadableLocations,\n    );\n\n    this.updateLocation(now, this.unavailableWriteableLocations, this.writeableLocations);\n    this.unavailableWriteableLocations = this.cleanUnavailableLocationList(\n      now,\n      this.unavailableWriteableLocations,\n    );\n  }\n\n  /**\n   * update the locationUnavailability to undefined if the location is available again\n   * @param now - current time\n   * @param unavailableLocations - list of unavailable locations\n   * @param allLocations - list of all locations\n   */\n  private updateLocation(\n    now: number,\n    unavailableLocations: Location[],\n    allLocations: Location[],\n  ): void {\n    for (const location of unavailableLocations) {\n      const unavailableLocation = allLocations.find((loc) => loc.name === location.name);\n      if (\n        unavailableLocation &&\n        now - unavailableLocation.lastUnavailabilityTimestampInMs >\n          Constants.LocationUnavailableExpirationTimeInMs\n      ) {\n        unavailableLocation.unavailable = false;\n      }\n    }\n  }\n\n  private cleanUnavailableLocationList(now: number, unavailableLocations: Location[]): Location[] {\n    return unavailableLocations.filter((loc) => {\n      return (\n        now - loc.lastUnavailabilityTimestampInMs < Constants.LocationUnavailableExpirationTimeInMs\n      );\n    });\n  }\n\n  /**\n   * Gets the database account first by using the default endpoint, and if that doesn't returns\n   * use the endpoints for the preferred locations in the order they are specified to get\n   * the database account.\n   */\n  private async getDatabaseAccountFromAnyEndpoint(\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<DatabaseAccount> {\n    try {\n      const options = { urlConnection: this.defaultEndpoint };\n      const { resource: databaseAccount } = await this.readDatabaseAccount(diagnosticNode, options);\n      return databaseAccount;\n      // If for any reason(non - globaldb related), we are not able to get the database\n      // account from the above call to readDatabaseAccount,\n      // we would try to get this information from any of the preferred locations that the user\n      // might have specified (by creating a locational endpoint)\n      // and keeping eating the exception until we get the database account and return None at the end,\n      // if we are not able to get that info from any endpoints\n    } catch (err: any) {\n      // TODO: Tracing\n    }\n\n    if (this.preferredLocations) {\n      for (const location of this.preferredLocations) {\n        try {\n          const locationalEndpoint = GlobalEndpointManager.getLocationalEndpoint(\n            this.defaultEndpoint,\n            location,\n          );\n          const options = { urlConnection: locationalEndpoint };\n          const { resource: databaseAccount } = await this.readDatabaseAccount(\n            diagnosticNode,\n            options,\n          );\n          if (databaseAccount) {\n            return databaseAccount;\n          }\n        } catch (err: any) {\n          // TODO: Tracing\n        }\n      }\n    }\n  }\n\n  /**\n   * Gets the locational endpoint using the location name passed to it using the default endpoint.\n   *\n   * @param defaultEndpoint - The default endpoint to use for the endpoint.\n   * @param locationName    - The location name for the azure region like \"East US\".\n   */\n  private static getLocationalEndpoint(defaultEndpoint: string, locationName: string): string {\n    // For defaultEndpoint like 'https://contoso.documents.azure.com:443/' parse it to generate URL format\n    // This defaultEndpoint should be global endpoint(and cannot be a locational endpoint)\n    // and we agreed to document that\n    const endpointUrl = new URL(defaultEndpoint);\n\n    // hostname attribute in endpointUrl will return 'contoso.documents.azure.com'\n    if (endpointUrl.hostname) {\n      const hostnameParts = endpointUrl.hostname.toString().toLowerCase().split(\".\");\n      if (hostnameParts) {\n        // globalDatabaseAccountName will return 'contoso'\n        const globalDatabaseAccountName = hostnameParts[0];\n\n        // Prepare the locationalDatabaseAccountName as contoso-EastUS for location_name 'East US'\n        const locationalDatabaseAccountName =\n          globalDatabaseAccountName + \"-\" + locationName.replace(\" \", \"\");\n\n        // Replace 'contoso' with 'contoso-EastUS' and\n        // return locationalEndpoint as https://contoso-EastUS.documents.azure.com:443/\n        const locationalEndpoint = defaultEndpoint\n          .toLowerCase()\n          .replace(globalDatabaseAccountName, locationalDatabaseAccountName);\n        return locationalEndpoint;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Refreshes the enablePartitionLevelFailover and enablePartitionLevelCircuitBreaker flag\n   * based on the value from database account.\n   * @param enablePerPartitionFailover - value from database account\n   */\n  private refreshPPAFFeatureFlag(enablePerPartitionFailover: boolean): void {\n    // If the enablePartitionLevelFailover is true, but PPAF is not enabled on the account,\n    // we will override it to false.\n    if (enablePerPartitionFailover === false) {\n      this.enablePartitionLevelFailover = enablePerPartitionFailover;\n      this.enablePartitionLevelCircuitBreaker = enablePerPartitionFailover;\n    }\n  }\n}\n"]}